{"ast":null,"code":"import _asyncToGenerator from \"D:/Download/Compressed/quiz-portal-frontend-code-master/quiz-portal-frontend-code-master/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { VERSION, EventEmitter, forwardRef, Component, Input, Output, NgModule } from '@angular/core';\nimport { first } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { createIntegrationUsageDataPlugin, isCKEditorFreeLicense, appendExtraPluginsToEditorConfig, uid } from '@ckeditor/ckeditor5-integrations-common';\nfunction CKEditorComponent_ng_template_0_Template(rf, ctx) {}\nexport { loadCKEditorCloud } from '@ckeditor/ckeditor5-integrations-common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * This part of the code is not executed in open-source implementations using a GPL key.\n * It only runs when a specific license key is provided. If you are uncertain whether\n * this applies to your installation, please contact our support team.\n */\nconst AngularIntegrationUsageDataPlugin = createIntegrationUsageDataPlugin('angular', {\n  version: /* replace-version:start */'9.1.0' /* replace-version:end */,\n  frameworkVersion: VERSION.full\n});\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n/**\n * Appends all integration plugins to the editor configuration.\n *\n * @param editorConfig The editor configuration.\n * @returns The editor configuration with all integration plugins appended.\n */\nfunction appendAllIntegrationPluginsToConfig(editorConfig) {\n  const extraPlugins = [];\n  if (!isCKEditorFreeLicense(editorConfig.licenseKey)) {\n    /**\n     * This part of the code is not executed in open-source implementations using a GPL key.\n     * It only runs when a specific license key is provided. If you are uncertain whether\n     * this applies to your installation, please contact our support team.\n     */\n    extraPlugins.push(AngularIntegrationUsageDataPlugin);\n  }\n  return appendExtraPluginsToEditorConfig(editorConfig, extraPlugins);\n}\nconst ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from Angular integration (@ckeditor/ckeditor5-angular)';\nlet CKEditorComponent = /*#__PURE__*/(() => {\n  class CKEditorComponent {\n    /**\n     * The reference to the DOM element created by the component.\n     */\n    elementRef;\n    /**\n     * The constructor of the editor to be used for the instance of the component.\n     * It can be e.g. the `ClassicEditorBuild`, `InlineEditorBuild` or some custom editor.\n     */\n    editor;\n    /**\n     * The configuration of the editor.\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editorconfig-EditorConfig.html\n     * to learn more.\n     */\n    config = {};\n    /**\n     * The initial data of the editor. Useful when not using the ngModel.\n     * See https://angular.io/api/forms/NgModel to learn more.\n     */\n    data = '';\n    /**\n     * Tag name of the editor component.\n     *\n     * The default tag is 'div'.\n     */\n    tagName = 'div';\n    // TODO Change to ContextWatchdog<Editor, HTMLElement> after new ckeditor5 alpha release\n    /**\n     * The context watchdog.\n     */\n    watchdog;\n    /**\n     * Config for the EditorWatchdog.\n     */\n    editorWatchdogConfig;\n    /**\n     * Allows disabling the two-way data binding mechanism. Disabling it can boost performance for large documents.\n     *\n     * When a component is connected using the [(ngModel)] or [formControl] directives and this value is set to true then none of the data\n     * will ever be synchronized.\n     *\n     * An integrator must call `editor.data.get()` manually once the application needs the editor's data.\n     * An editor instance can be received in the `ready()` callback.\n     */\n    disableTwoWayDataBinding = false;\n    /**\n     * When set `true`, the editor becomes read-only.\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#member-isReadOnly\n     * to learn more.\n     */\n    set disabled(isDisabled) {\n      this.setDisabledState(isDisabled);\n    }\n    get disabled() {\n      if (this.editorInstance) {\n        return this.editorInstance.isReadOnly;\n      }\n      return this.initiallyDisabled;\n    }\n    /**\n     * Fires when the editor is ready. It corresponds with the `editor#ready`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html#event-ready\n     * event.\n     */\n    ready = new EventEmitter();\n    /**\n     * Fires when the content of the editor has changed. It corresponds with the `editor.model.document#change`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_model_document-Document.html#event-change\n     * event.\n     */\n    change = new EventEmitter();\n    /**\n     * Fires when the editing view of the editor is blurred. It corresponds with the `editor.editing.view.document#blur`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:blur\n     * event.\n     */\n    blur = new EventEmitter();\n    /**\n     * Fires when the editing view of the editor is focused. It corresponds with the `editor.editing.view.document#focus`\n     * https://ckeditor.com/docs/ckeditor5/latest/api/module_engine_view_document-Document.html#event-event:focus\n     * event.\n     */\n    focus = new EventEmitter();\n    /**\n     * Fires when the editor component crashes.\n     */\n    error = new EventEmitter();\n    /**\n     * The instance of the editor created by this component.\n     */\n    get editorInstance() {\n      let editorWatchdog = this.editorWatchdog;\n      if (this.watchdog) {\n        // Temporarily use the `_watchdogs` internal map as the `getItem()` method throws\n        // an error when the item is not registered yet.\n        // See https://github.com/ckeditor/ckeditor5-angular/issues/177.\n        // TODO should be able to change when new chages in Watcdog are released.\n        editorWatchdog = this.watchdog._watchdogs.get(this.id);\n      }\n      if (editorWatchdog) {\n        return editorWatchdog.editor;\n      }\n      return null;\n    }\n    /**\n     * The editor watchdog. It is created when the context watchdog is not passed to the component.\n     * It keeps the editor running.\n     */\n    editorWatchdog;\n    /**\n     * If the component is read–only before the editor instance is created, it remembers that state,\n     * so the editor can become read–only once it is ready.\n     */\n    initiallyDisabled = false;\n    /**\n     * An instance of https://angular.io/api/core/NgZone to allow the interaction with the editor\n     * withing the Angular event loop.\n     */\n    ngZone;\n    /**\n     * A callback executed when the content of the editor changes. Part of the\n     * `ControlValueAccessor` (https://angular.io/api/forms/ControlValueAccessor) interface.\n     *\n     * Note: Unset unless the component uses the `ngModel`.\n     */\n    cvaOnChange;\n    /**\n     * A callback executed when the editor has been blurred. Part of the\n     * `ControlValueAccessor` (https://angular.io/api/forms/ControlValueAccessor) interface.\n     *\n     * Note: Unset unless the component uses the `ngModel`.\n     */\n    cvaOnTouched;\n    /**\n     * Reference to the source element used by the editor.\n     */\n    editorElement;\n    /**\n     * A lock flag preventing from calling the `cvaOnChange()` during setting editor data.\n     */\n    isEditorSettingData = false;\n    id = uid();\n    getId() {\n      return this.id;\n    }\n    constructor(elementRef, ngZone) {\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.checkVersion();\n    }\n    checkVersion() {\n      // To avoid issues with the community typings and CKEditor 5, let's treat window as any. See #342.\n      const {\n        CKEDITOR_VERSION\n      } = window;\n      if (!CKEDITOR_VERSION) {\n        return console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n      }\n      const [major] = CKEDITOR_VERSION.split('.').map(Number);\n      if (major >= 42 || CKEDITOR_VERSION.startsWith('0.0.0')) {\n        return;\n      }\n      console.warn('The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.');\n    }\n    // Implementing the OnChanges interface. Whenever the `data` property is changed, update the editor content.\n    ngOnChanges(changes) {\n      if (Object.prototype.hasOwnProperty.call(changes, 'data') && changes.data && !changes.data.isFirstChange()) {\n        this.writeValue(changes.data.currentValue);\n      }\n    }\n    // Implementing the AfterViewInit interface.\n    ngAfterViewInit() {\n      this.attachToWatchdog();\n    }\n    // Implementing the OnDestroy interface.\n    ngOnDestroy() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (_this.watchdog) {\n          yield _this.watchdog.remove(_this.id);\n        } else if (_this.editorWatchdog && _this.editorWatchdog.editor) {\n          yield _this.editorWatchdog.destroy();\n          _this.editorWatchdog = undefined;\n        }\n      })();\n    }\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n    writeValue(value) {\n      // This method is called with the `null` value when the form resets.\n      // A component's responsibility is to restore to the initial state.\n      if (value === null) {\n        value = '';\n      }\n      // If already initialized.\n      if (this.editorInstance) {\n        // The lock mechanism prevents from calling `cvaOnChange()` during changing\n        // the editor state. See #139\n        this.isEditorSettingData = true;\n        this.editorInstance.data.set(value);\n        this.isEditorSettingData = false;\n      }\n      // If not, wait for it to be ready; store the data.\n      else {\n        // If the editor element is already available, then update its content.\n        this.data = value;\n        // If not, then wait until it is ready\n        // and change data only for the first `ready` event.\n        this.ready.pipe(first()).subscribe(editor => {\n          editor.data.set(this.data);\n        });\n      }\n    }\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n    registerOnChange(callback) {\n      this.cvaOnChange = callback;\n    }\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n    registerOnTouched(callback) {\n      this.cvaOnTouched = callback;\n    }\n    // Implementing the ControlValueAccessor interface (only when binding to ngModel).\n    setDisabledState(isDisabled) {\n      // If already initialized.\n      if (this.editorInstance) {\n        if (isDisabled) {\n          this.editorInstance.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n        } else {\n          this.editorInstance.disableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n        }\n      }\n      // Store the state anyway to use it once the editor is created.\n      this.initiallyDisabled = isDisabled;\n    }\n    /**\n     * Creates the editor instance, sets initial editor data, then integrates\n     * the editor with the Angular component. This method does not use the `editor.data.set()`\n     * because of the issue in the collaboration mode (#6).\n     */\n    attachToWatchdog() {\n      var _this2 = this;\n      // TODO: elementOrData parameter type can be simplified to HTMLElemen after templated Watchdog will be released.\n      const creator = (elementOrData, config) => {\n        return this.ngZone.runOutsideAngular(/*#__PURE__*/_asyncToGenerator(function* () {\n          _this2.elementRef.nativeElement.appendChild(elementOrData);\n          const editor = yield _this2.editor.create(elementOrData, config);\n          if (_this2.initiallyDisabled) {\n            editor.enableReadOnlyMode(ANGULAR_INTEGRATION_READ_ONLY_LOCK_ID);\n          }\n          _this2.ngZone.run(() => {\n            _this2.ready.emit(editor);\n          });\n          _this2.setUpEditorEvents(editor);\n          return editor;\n        }));\n      };\n      const destructor = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (editor) {\n          yield editor.destroy();\n          _this2.elementRef.nativeElement.removeChild(_this2.editorElement);\n        });\n        return function destructor(_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      const emitError = e => {\n        // Do not run change detection by re-entering the Angular zone if the `error`\n        // emitter doesn't have any subscribers.\n        // Subscribers are pushed onto the list whenever `error` is listened inside the template:\n        // `<ckeditor (error)=\"onError(...)\"></ckeditor>`.\n        if (hasObservers(this.error)) {\n          this.ngZone.run(() => this.error.emit(e));\n        } else {\n          // Print error to the console when there are no subscribers to the `error` event.\n          console.error(e);\n        }\n      };\n      const element = document.createElement(this.tagName);\n      const config = this.getConfig();\n      this.editorElement = element;\n      // Based on the presence of the watchdog decide how to initialize the editor.\n      if (this.watchdog) {\n        // When the context watchdog is passed add the new item to it based on the passed configuration.\n        this.watchdog.add({\n          id: this.id,\n          type: 'editor',\n          creator,\n          destructor,\n          sourceElementOrData: element,\n          config\n        }).catch(e => {\n          emitError(e);\n        });\n        this.watchdog.on('itemError', (_, {\n          itemId\n        }) => {\n          if (itemId === this.id) {\n            emitError();\n          }\n        });\n      } else {\n        // In the other case create the watchdog by hand to keep the editor running.\n        const editorWatchdog = new this.editor.EditorWatchdog(this.editor, this.editorWatchdogConfig);\n        editorWatchdog.setCreator(creator);\n        editorWatchdog.setDestructor(destructor);\n        editorWatchdog.on('error', emitError);\n        this.editorWatchdog = editorWatchdog;\n        this.ngZone.runOutsideAngular(() => {\n          // Note: must be called outside of the Angular zone too because `create` is calling\n          // `_startErrorHandling` within a microtask which sets up `error` listener on the window.\n          editorWatchdog.create(element, config).catch(e => {\n            emitError(e);\n          });\n        });\n      }\n    }\n    getConfig() {\n      if (this.data && this.config.initialData) {\n        throw new Error('Editor data should be provided either using `config.initialData` or `data` properties.');\n      }\n      const config = {\n        ...this.config\n      };\n      // Merge two possible ways of providing data into the `config.initialData` field.\n      const initialData = this.config.initialData || this.data;\n      if (initialData) {\n        // Define the `config.initialData` only when the initial content is specified.\n        config.initialData = initialData;\n      }\n      return appendAllIntegrationPluginsToConfig(config);\n    }\n    /**\n     * Integrates the editor with the component by attaching related event listeners.\n     */\n    setUpEditorEvents(editor) {\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on('change:data', evt => {\n        this.ngZone.run(() => {\n          if (this.disableTwoWayDataBinding) {\n            return;\n          }\n          if (this.cvaOnChange && !this.isEditorSettingData) {\n            const data = editor.data.get();\n            this.cvaOnChange(data);\n          }\n          this.change.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n      viewDocument.on('focus', evt => {\n        this.ngZone.run(() => {\n          this.focus.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n      viewDocument.on('blur', evt => {\n        this.ngZone.run(() => {\n          if (this.cvaOnTouched) {\n            this.cvaOnTouched();\n          }\n          this.blur.emit({\n            event: evt,\n            editor\n          });\n        });\n      });\n    }\n    static ɵfac = function CKEditorComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CKEditorComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CKEditorComponent,\n      selectors: [[\"ckeditor\"]],\n      inputs: {\n        editor: \"editor\",\n        config: \"config\",\n        data: \"data\",\n        tagName: \"tagName\",\n        watchdog: \"watchdog\",\n        editorWatchdogConfig: \"editorWatchdogConfig\",\n        disableTwoWayDataBinding: \"disableTwoWayDataBinding\",\n        disabled: \"disabled\"\n      },\n      outputs: {\n        ready: \"ready\",\n        change: \"change\",\n        blur: \"blur\",\n        focus: \"focus\",\n        error: \"error\"\n      },\n      standalone: false,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        useExisting: forwardRef(() => CKEditorComponent),\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature],\n      decls: 1,\n      vars: 0,\n      template: function CKEditorComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, CKEditorComponent_ng_template_0_Template, 0, 0, \"ng-template\");\n        }\n      },\n      encapsulation: 2\n    });\n  }\n  return CKEditorComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction hasObservers(emitter) {\n  // Cast to `any` because `observed` property is available in RxJS >= 7.2.0.\n  // Fallback to checking `observers` list if this property is not defined.\n  return emitter.observed || emitter.observers.length > 0;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nlet CKEditorModule = /*#__PURE__*/(() => {\n  class CKEditorModule {\n    static ɵfac = function CKEditorModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CKEditorModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CKEditorModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [FormsModule, CommonModule]\n    });\n  }\n  return CKEditorModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CKEditorComponent, CKEditorModule };\n//# sourceMappingURL=ckeditor-ckeditor5-angular.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}