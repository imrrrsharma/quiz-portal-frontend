{"ast":null,"code":"import _asyncToGenerator from \"D:/Download/Compressed/quiz-portal-frontend-code-master/quiz-portal-frontend-code-master/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction createDefer() {\n  const deferred = {\n    resolve: null,\n    promise: null\n  };\n  deferred.promise = new Promise(resolve => {\n    deferred.resolve = resolve;\n  });\n  return deferred;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction waitFor(callback, {\n  timeOutAfter = 500,\n  retryAfter = 100\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const startTime = Date.now();\n    let lastError = null;\n    const timeoutTimerId = setTimeout(() => {\n      reject(lastError ?? new Error(\"Timeout\"));\n    }, timeOutAfter);\n    const _tick = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        try {\n          const result = yield callback();\n          clearTimeout(timeoutTimerId);\n          resolve(result);\n        } catch (err) {\n          lastError = err;\n          if (Date.now() - startTime > timeOutAfter) {\n            reject(err);\n          } else {\n            setTimeout(_tick, retryAfter);\n          }\n        }\n      });\n      return function tick() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    _tick();\n  });\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nconst INJECTED_SCRIPTS = /* @__PURE__ */new Map();\nfunction injectScript(src, {\n  attributes\n} = {}) {\n  if (INJECTED_SCRIPTS.has(src)) {\n    return INJECTED_SCRIPTS.get(src);\n  }\n  const maybePrevScript = document.querySelector(`script[src=\"${src}\"]`);\n  if (maybePrevScript) {\n    console.warn(`Script with \"${src}\" src is already present in DOM!`);\n    maybePrevScript.remove();\n  }\n  const promise = new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.onerror = reject;\n    script.onload = () => {\n      resolve();\n    };\n    for (const [key, value] of Object.entries(attributes || {})) {\n      script.setAttribute(key, value);\n    }\n    script.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n    script.type = \"text/javascript\";\n    script.async = true;\n    script.src = src;\n    document.head.appendChild(script);\n    const observer = new MutationObserver(mutations => {\n      const removedNodes = mutations.flatMap(mutation => Array.from(mutation.removedNodes));\n      if (removedNodes.includes(script)) {\n        INJECTED_SCRIPTS.delete(src);\n        observer.disconnect();\n      }\n    });\n    observer.observe(document.head, {\n      childList: true,\n      subtree: true\n    });\n  });\n  INJECTED_SCRIPTS.set(src, promise);\n  return promise;\n}\nfunction injectScriptsInParallel(_x, _x2) {\n  return _injectScriptsInParallel.apply(this, arguments);\n}\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction _injectScriptsInParallel() {\n  _injectScriptsInParallel = _asyncToGenerator(function* (sources, props) {\n    yield Promise.all(sources.map(src => injectScript(src, props)));\n  });\n  return _injectScriptsInParallel.apply(this, arguments);\n}\nconst INJECTED_STYLESHEETS = /* @__PURE__ */new Map();\nfunction injectStylesheet({\n  href,\n  placementInHead = \"start\",\n  attributes = {}\n}) {\n  if (INJECTED_STYLESHEETS.has(href)) {\n    return INJECTED_STYLESHEETS.get(href);\n  }\n  const maybePrevStylesheet = document.querySelector(`link[href=\"${href}\"][rel=\"stylesheet\"]`);\n  if (maybePrevStylesheet) {\n    console.warn(`Stylesheet with \"${href}\" href is already present in DOM!`);\n    maybePrevStylesheet.remove();\n  }\n  const appendLinkTagToHead = link => {\n    const previouslyInjectedLinks = Array.from(document.head.querySelectorAll('link[data-injected-by=\"ckeditor-integration\"]'));\n    switch (placementInHead) {\n      case \"start\":\n        if (previouslyInjectedLinks.length) {\n          previouslyInjectedLinks.slice(-1)[0].after(link);\n        } else {\n          document.head.insertBefore(link, document.head.firstChild);\n        }\n        break;\n      case \"end\":\n        document.head.appendChild(link);\n        break;\n    }\n  };\n  const promise = new Promise((resolve, reject) => {\n    const link = document.createElement(\"link\");\n    for (const [key, value] of Object.entries(attributes || {})) {\n      link.setAttribute(key, value);\n    }\n    link.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n    link.rel = \"stylesheet\";\n    link.href = href;\n    link.onerror = reject;\n    link.onload = () => {\n      resolve();\n    };\n    appendLinkTagToHead(link);\n    const observer = new MutationObserver(mutations => {\n      const removedNodes = mutations.flatMap(mutation => Array.from(mutation.removedNodes));\n      if (removedNodes.includes(link)) {\n        INJECTED_STYLESHEETS.delete(href);\n        observer.disconnect();\n      }\n    });\n    observer.observe(document.head, {\n      childList: true,\n      subtree: true\n    });\n  });\n  INJECTED_STYLESHEETS.set(href, promise);\n  return promise;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction isSSR() {\n  return typeof window === \"undefined\";\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction once(fn) {\n  let lastResult = null;\n  return (...args) => {\n    if (!lastResult) {\n      lastResult = {\n        current: fn(...args)\n      };\n    }\n    return lastResult.current;\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction overwriteArray(source, destination) {\n  destination.length = 0;\n  destination.push(...source);\n  return destination;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction overwriteObject(source, destination) {\n  for (const prop of Object.getOwnPropertyNames(destination)) {\n    delete destination[prop];\n  }\n  for (const [key, value] of Object.entries(source)) {\n    if (value !== destination && key !== \"prototype\" && key !== \"__proto__\") {\n      destination[key] = value;\n    }\n  }\n  return destination;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction preloadResource(url, {\n  attributes\n} = {}) {\n  if (document.head.querySelector(`link[href=\"${url}\"][rel=\"preload\"]`)) {\n    return;\n  }\n  const link = document.createElement(\"link\");\n  for (const [key, value] of Object.entries(attributes || {})) {\n    link.setAttribute(key, value);\n  }\n  link.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n  link.rel = \"preload\";\n  link.as = detectTypeOfResource(url);\n  link.href = url;\n  document.head.insertBefore(link, document.head.firstChild);\n}\nfunction detectTypeOfResource(url) {\n  switch (true) {\n    case /\\.css$/.test(url):\n      return \"style\";\n    case /\\.js$/.test(url):\n      return \"script\";\n    default:\n      return \"fetch\";\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction shallowCompareArrays(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nconst HEX_NUMBERS = new Array(256).fill(\"\").map((_, index) => (\"0\" + index.toString(16)).slice(-2));\nfunction uid() {\n  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));\n  return \"e\" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction uniq(source) {\n  return Array.from(new Set(source));\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction waitForWindowEntry(_x3, _x4) {\n  return _waitForWindowEntry.apply(this, arguments);\n}\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction _waitForWindowEntry() {\n  _waitForWindowEntry = _asyncToGenerator(function* (entryNames, config) {\n    const tryPickBundle = () => entryNames.map(name => window[name]).filter(Boolean)[0];\n    return waitFor(() => {\n      const result = tryPickBundle();\n      if (!result) {\n        throw new Error(`Window entry \"${entryNames.join(\",\")}\" not found.`);\n      }\n      return result;\n    }, config);\n  });\n  return _waitForWindowEntry.apply(this, arguments);\n}\nfunction filterObjectValues(obj, filter) {\n  const filteredEntries = Object.entries(obj).filter(([key, value]) => filter(value, key));\n  return Object.fromEntries(filteredEntries);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction filterBlankObjectValues(obj) {\n  return filterObjectValues(obj, value => value !== null && value !== void 0);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction mapObjectValues(obj, mapper) {\n  const mappedEntries = Object.entries(obj).map(([key, value]) => [key, mapper(value, key)]);\n  return Object.fromEntries(mappedEntries);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction without(itemsToRemove, items) {\n  return items.filter(item => !itemsToRemove.includes(item));\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction appendExtraPluginsToEditorConfig(config, plugins) {\n  const extraPlugins = config.extraPlugins || [];\n  return {\n    ...config,\n    extraPlugins: [...extraPlugins, ...plugins.filter(item => !extraPlugins.includes(item))]\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction isSemanticVersion(version) {\n  return !!version && /^\\d+\\.\\d+\\.\\d+/.test(version);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction isCKCdnTestingVersion(version) {\n  if (!version) {\n    return false;\n  }\n  return [\"nightly\", \"alpha\", \"internal\"].some(testVersion => version.includes(testVersion));\n}\nfunction isCKCdnVersion(version) {\n  return isSemanticVersion(version) || isCKCdnTestingVersion(version);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction destructureSemanticVersion(version) {\n  if (!isSemanticVersion(version)) {\n    throw new Error(`Invalid semantic version: ${version || \"<blank>\"}.`);\n  }\n  const [major, minor, patch] = version.split(\".\");\n  return {\n    major: Number.parseInt(major, 10),\n    minor: Number.parseInt(minor, 10),\n    patch: Number.parseInt(patch, 10)\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction getLicenseVersionFromEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    return 3;\n  }\n  const {\n    major\n  } = destructureSemanticVersion(version);\n  switch (true) {\n    case major >= 44:\n      return 3;\n    case major >= 38:\n      return 2;\n    default:\n      return 1;\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction getCKBaseBundleInstallationInfo() {\n  const {\n    CKEDITOR_VERSION,\n    CKEDITOR\n  } = window;\n  if (!isCKCdnVersion(CKEDITOR_VERSION)) {\n    return null;\n  }\n  return {\n    source: CKEDITOR ? \"cdn\" : \"npm\",\n    version: CKEDITOR_VERSION\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction getSupportedLicenseVersionInstallationInfo() {\n  const installationInfo = getCKBaseBundleInstallationInfo();\n  if (!installationInfo) {\n    return null;\n  }\n  return getLicenseVersionFromEditorVersion(installationInfo.version);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction isCKEditorFreeLicense(licenseKey, licenseVersion) {\n  licenseVersion ||= getSupportedLicenseVersionInstallationInfo() || void 0;\n  switch (licenseVersion) {\n    case 1:\n    case 2:\n      return licenseKey === void 0;\n    case 3:\n      return licenseKey === \"GPL\";\n    default:\n      {\n        return false;\n      }\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction createIntegrationUsageDataPlugin(integrationName, usageData) {\n  return function IntegrationUsageDataPlugin(editor) {\n    if (isCKEditorFreeLicense(editor.config.get(\"licenseKey\"))) {\n      return;\n    }\n    editor.on(\"collectUsageData\", (source, {\n      setUsageData\n    }) => {\n      setUsageData(`integration.${integrationName}`, usageData);\n    });\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nconst CK_CDN_URL = \"https://cdn.ckeditor.com\";\nfunction createCKCdnUrl(bundle, file, version) {\n  return `${CK_CDN_URL}/${bundle}/${version}/${file}`;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nconst CKBOX_CDN_URL = \"https://cdn.ckbox.io\";\nfunction createCKBoxCdnUrl(bundle, file, version) {\n  return `${CKBOX_CDN_URL}/${bundle}/${version}/${file}`;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nconst CK_DOCS_URL = \"https://ckeditor.com/docs/ckeditor5\";\nfunction createCKDocsUrl(path, version = \"latest\") {\n  return `${CK_DOCS_URL}/${version}/${path}`;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction createCKCdnBaseBundlePack({\n  version,\n  translations,\n  createCustomCdnUrl = createCKCdnUrl\n}) {\n  const urls = {\n    scripts: [\n    // Load the main script of the base features.\n    createCustomCdnUrl(\"ckeditor5\", \"ckeditor5.umd.js\", version),\n    // Load all JavaScript files from the base features.\n    // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n    ...without([\"en\"], translations || []).map(translation => createCustomCdnUrl(\"ckeditor5\", `translations/${translation}.umd.js`, version))],\n    stylesheets: [createCustomCdnUrl(\"ckeditor5\", \"ckeditor5.css\", version)]\n  };\n  return {\n    // Preload resources specified in the pack, before loading the main script.\n    preload: [...urls.stylesheets, ...urls.scripts],\n    scripts: [(\n    /*#__PURE__*/\n    // It's safe to load translations and the main script in parallel.\n    function () {\n      var _ref2 = _asyncToGenerator(function* (attributes) {\n        return injectScriptsInParallel(urls.scripts, attributes);\n      });\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }())],\n    // Load all stylesheets of the base features.\n    stylesheets: urls.stylesheets,\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: function () {\n      var _ref3 = _asyncToGenerator(function* () {\n        return waitForWindowEntry([\"CKEDITOR\"]);\n      });\n      return function checkPluginLoaded() {\n        return _ref3.apply(this, arguments);\n      };\n    }(),\n    // Check if the CKEditor base bundle is already loaded and throw an error if it is.\n    beforeInject: () => {\n      const installationInfo = getCKBaseBundleInstallationInfo();\n      switch (installationInfo?.source) {\n        case \"npm\":\n          throw new Error(\"CKEditor 5 is already loaded from npm. Check the migration guide for more details: \" + createCKDocsUrl(\"updating/migration-to-cdn/vanilla-js.html\"));\n        case \"cdn\":\n          if (installationInfo.version !== version) {\n            throw new Error(`CKEditor 5 is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKEditor 5 to allow loading the ${version} version.`);\n          }\n          break;\n      }\n    }\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction createCKCdnPremiumBundlePack({\n  version,\n  translations,\n  createCustomCdnUrl = createCKCdnUrl\n}) {\n  const urls = {\n    scripts: [\n    // Load the main script of the premium features.\n    createCustomCdnUrl(\"ckeditor5-premium-features\", \"ckeditor5-premium-features.umd.js\", version),\n    // Load all JavaScript files from the premium features.\n    // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n    ...without([\"en\"], translations || []).map(translation => createCustomCdnUrl(\"ckeditor5-premium-features\", `translations/${translation}.umd.js`, version))],\n    stylesheets: [createCustomCdnUrl(\"ckeditor5-premium-features\", \"ckeditor5-premium-features.css\", version)]\n  };\n  return {\n    // Preload resources specified in the pack, before loading the main script.\n    preload: [...urls.stylesheets, ...urls.scripts],\n    scripts: [(\n    /*#__PURE__*/\n    // It's safe to load translations and the main script in parallel.\n    function () {\n      var _ref4 = _asyncToGenerator(function* (attributes) {\n        return injectScriptsInParallel(urls.scripts, attributes);\n      });\n      return function (_x6) {\n        return _ref4.apply(this, arguments);\n      };\n    }())],\n    // Load all stylesheets of the premium features.\n    stylesheets: urls.stylesheets,\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: function () {\n      var _ref5 = _asyncToGenerator(function* () {\n        return waitForWindowEntry([\"CKEDITOR_PREMIUM_FEATURES\"]);\n      });\n      return function checkPluginLoaded() {\n        return _ref5.apply(this, arguments);\n      };\n    }()\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction loadCKCdnResourcesPack(_x7) {\n  return _loadCKCdnResourcesPack.apply(this, arguments);\n}\nfunction _loadCKCdnResourcesPack() {\n  _loadCKCdnResourcesPack = _asyncToGenerator(function* (pack) {\n    let {\n      htmlAttributes = {},\n      scripts = [],\n      stylesheets = [],\n      preload,\n      beforeInject,\n      checkPluginLoaded\n    } = normalizeCKCdnResourcesPack(pack);\n    beforeInject?.();\n    if (!preload) {\n      preload = uniq([...stylesheets.filter(item => typeof item === \"string\"), ...scripts.filter(item => typeof item === \"string\")]);\n    }\n    for (const url of preload) {\n      preloadResource(url, {\n        attributes: htmlAttributes\n      });\n    }\n    yield Promise.all(uniq(stylesheets).map(href => injectStylesheet({\n      href,\n      attributes: htmlAttributes,\n      placementInHead: \"start\"\n    })));\n    for (const script of uniq(scripts)) {\n      const injectorProps = {\n        attributes: htmlAttributes\n      };\n      if (typeof script === \"string\") {\n        yield injectScript(script, injectorProps);\n      } else {\n        yield script(injectorProps);\n      }\n    }\n    return checkPluginLoaded?.();\n  });\n  return _loadCKCdnResourcesPack.apply(this, arguments);\n}\nfunction normalizeCKCdnResourcesPack(pack) {\n  if (Array.isArray(pack)) {\n    return {\n      scripts: pack.filter(item => typeof item === \"function\" || item.endsWith(\".js\")),\n      stylesheets: pack.filter(item => item.endsWith(\".css\"))\n    };\n  }\n  if (typeof pack === \"function\") {\n    return {\n      checkPluginLoaded: pack\n    };\n  }\n  return pack;\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction combineCKCdnBundlesPacks(packs) {\n  const normalizedPacks = mapObjectValues(filterBlankObjectValues(packs), normalizeCKCdnResourcesPack);\n  const mergedPacks = Object.values(normalizedPacks).reduce((acc, pack) => {\n    acc.scripts.push(...(pack.scripts ?? []));\n    acc.stylesheets.push(...(pack.stylesheets ?? []));\n    acc.preload.push(...(pack.preload ?? []));\n    return acc;\n  }, {\n    preload: [],\n    scripts: [],\n    stylesheets: []\n  });\n  const checkPluginLoaded = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator(function* () {\n      const exportedGlobalVariables = /* @__PURE__ */Object.create(null);\n      for (const [name, pack] of Object.entries(normalizedPacks)) {\n        exportedGlobalVariables[name] = yield pack?.checkPluginLoaded?.();\n      }\n      return exportedGlobalVariables;\n    });\n    return function checkPluginLoaded() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  const beforeInject = () => {\n    for (const pack of Object.values(normalizedPacks)) {\n      pack.beforeInject?.();\n    }\n  };\n  return {\n    ...mergedPacks,\n    beforeInject,\n    checkPluginLoaded\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction getCKBoxInstallationInfo() {\n  const version = window.CKBox?.version;\n  if (!isSemanticVersion(version)) {\n    return null;\n  }\n  return {\n    source: \"cdn\",\n    version\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction createCKBoxBundlePack({\n  version,\n  theme = \"lark\",\n  translations,\n  createCustomCdnUrl = createCKBoxCdnUrl\n}) {\n  return {\n    // Load the main script of the base features.\n    scripts: [createCustomCdnUrl(\"ckbox\", \"ckbox.js\", version),\n    // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n    ...without([\"en\"], translations || []).map(translation => createCustomCdnUrl(\"ckbox\", `translations/${translation}.js`, version))],\n    // Load optional theme, if provided. It's not required but recommended because it improves the look and feel.\n    ...(theme && {\n      stylesheets: [createCustomCdnUrl(\"ckbox\", `styles/themes/${theme}.css`, version)]\n    }),\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: function () {\n      var _ref7 = _asyncToGenerator(function* () {\n        return waitForWindowEntry([\"CKBox\"]);\n      });\n      return function checkPluginLoaded() {\n        return _ref7.apply(this, arguments);\n      };\n    }(),\n    // Check if the CKBox bundle is already loaded and throw an error if it is.\n    beforeInject: () => {\n      const installationInfo = getCKBoxInstallationInfo();\n      if (installationInfo && installationInfo.version !== version) {\n        throw new Error(`CKBox is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKBox to allow loading the ${version} version.`);\n      }\n    }\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction isCKCdnSupportedByEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    return true;\n  }\n  const {\n    major\n  } = destructureSemanticVersion(version);\n  const licenseVersion = getLicenseVersionFromEditorVersion(version);\n  switch (licenseVersion) {\n    case 3:\n      return true;\n    default:\n      return major === 43;\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction combineCdnPluginsPacks(pluginsPacks) {\n  const normalizedPluginsPacks = mapObjectValues(pluginsPacks, (pluginPack, pluginName) => {\n    if (!pluginPack) {\n      return void 0;\n    }\n    const normalizedPluginPack = normalizeCKCdnResourcesPack(pluginPack);\n    return {\n      // Provide default window accessor object if the plugin pack does not define it.\n      checkPluginLoaded: function () {\n        var _ref8 = _asyncToGenerator(function* () {\n          return waitForWindowEntry([pluginName]);\n        });\n        return function checkPluginLoaded() {\n          return _ref8.apply(this, arguments);\n        };\n      }(),\n      // Transform the plugin pack to a normalized advanced pack.\n      ...normalizedPluginPack\n    };\n  });\n  return combineCKCdnBundlesPacks(normalizedPluginsPacks);\n}\n\n/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\nfunction loadCKEditorCloud(config) {\n  const {\n    version,\n    translations,\n    plugins,\n    premium,\n    ckbox,\n    createCustomCdnUrl,\n    injectedHtmlElementsAttributes = {\n      crossorigin: \"anonymous\"\n    }\n  } = config;\n  validateCKEditorVersion(version);\n  const pack = combineCKCdnBundlesPacks({\n    CKEditor: createCKCdnBaseBundlePack({\n      version,\n      translations,\n      createCustomCdnUrl\n    }),\n    ...(premium && {\n      CKEditorPremiumFeatures: createCKCdnPremiumBundlePack({\n        version,\n        translations,\n        createCustomCdnUrl\n      })\n    }),\n    ...(ckbox && {\n      CKBox: createCKBoxBundlePack(ckbox)\n    }),\n    loadedPlugins: combineCdnPluginsPacks(plugins ?? {})\n  });\n  return loadCKCdnResourcesPack({\n    ...pack,\n    htmlAttributes: injectedHtmlElementsAttributes\n  });\n}\nfunction validateCKEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    console.warn(\"You are using a testing version of CKEditor 5. Please remember that it is not suitable for production environments.\");\n  }\n  if (!isCKCdnSupportedByEditorVersion(version)) {\n    throw new Error(`The CKEditor 5 CDN can't be used with the given editor version: ${version}. Please make sure you are using at least the CKEditor 5 version 44.`);\n  }\n}\nexport { CKBOX_CDN_URL, CK_CDN_URL, INJECTED_SCRIPTS, INJECTED_STYLESHEETS, appendExtraPluginsToEditorConfig, createCKBoxCdnUrl, createCKCdnUrl, createDefer, createIntegrationUsageDataPlugin, filterBlankObjectValues, filterObjectValues, injectScript, injectScriptsInParallel, injectStylesheet, isCKEditorFreeLicense, isSSR, loadCKEditorCloud, mapObjectValues, once, overwriteArray, overwriteObject, preloadResource, shallowCompareArrays, uid, uniq, waitFor, waitForWindowEntry, without };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}